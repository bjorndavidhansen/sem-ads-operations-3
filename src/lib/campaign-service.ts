/**
 * Campaign Service for handling Google Ads campaign operations
 * Handles CRUD operations and specialized functions like cloning
 */
import { 
  Campaign, 
  AdGroup, 
  Keyword, 
  MatchType, 
  CampaignCloneConfig,
  CloneOperation
} from '../types/campaign-types';

/**
 * Service for campaign operations following the singleton pattern
 */
class CampaignService {
  private static instance: CampaignService;

  // Private constructor to enforce singleton pattern
  private constructor() {}

  /**
   * Get the singleton instance of CampaignService
   */
  public static getInstance(): CampaignService {
    if (!CampaignService.instance) {
      CampaignService.instance = new CampaignService();
    }
    return CampaignService.instance;
  }

  /**
   * Fetch campaigns from Google Ads API with optional filtering
   * @param accountId Google Ads account ID
   * @param filters Optional filters to apply
   */
  async fetchCampaigns(accountId: string, filters?: any): Promise<Campaign[]> {
    // TODO: Replace with actual API call to Google Ads API
    // For now, return mock data
    return this.getMockCampaigns();
  }

  /**
   * Clone campaigns according to the provided configuration
   * Handles the complete process including:
   * - Creating new campaigns
   * - Converting keywords to target match type
   * - Adding negative keywords
   * - Adjusting bids
   * 
   * @param operation Clone operation configuration
   * @param progressCallback Callback for reporting progress
   */
  async cloneCampaigns(
    operation: CloneOperation,
    progressCallback?: (progress: number) => void
  ): Promise<{
    success: boolean,
    createdCampaignIds: string[],
    errors: any[]
  }> {
    try {
      const { sourceCampaignIds, config } = operation;
      const createdCampaignIds: string[] = [];
      const errors: any[] = [];
      
      // Mock implementation - in real version, this would make API calls
      let progress = 0;
      
      // Fetch source campaigns
      const sourceCampaigns = await Promise.all(
        sourceCampaignIds.map(id => this.getCampaignById(id))
      );
      
      // Filter out null results (campaigns not found)
      const validCampaigns = sourceCampaigns.filter(
        (campaign): campaign is Campaign => campaign !== null
      );
      
      if (progressCallback) {
        progress += 10;
        progressCallback(progress);
      }
      
      // Process each campaign
      for (let i = 0; i < validCampaigns.length; i++) {
        const sourceCampaign = validCampaigns[i];
        try {
          // Generate new campaign name based on pattern
          const newName = this.generateCloneName(
            sourceCampaign.name, 
            config.namingPattern,
            config.sourceMatchType,
            config.targetMatchType
          );
          
          // Create a deep copy and modify
          const newCampaign: Partial<Campaign> = {
            ...JSON.parse(JSON.stringify(sourceCampaign)),
            name: newName,
            id: `new_${Date.now()}_${i}`, // This would be generated by the API
          };
          
          // Convert keywords to target match type
          if (newCampaign.adGroups) {
            newCampaign.adGroups = this.convertAdGroupKeywords(
              newCampaign.adGroups as AdGroup[],
              config.sourceMatchType,
              config.targetMatchType,
              config.bidAdjustmentFactor
            );
          }
          
          // In real implementation: Make API call to create campaign
          // For mock: just log and add to result
          console.log(`Created cloned campaign: ${newName}`);
          createdCampaignIds.push(newCampaign.id as string);
          
          // If configured, add negative keywords
          if (config.addNegativeKeywords) {
            await this.addNegativeKeywords(
              newCampaign.id as string,
              this.extractKeywordsForNegatives(sourceCampaign, config.sourceMatchType)
            );
          }
          
          // Update progress
          if (progressCallback) {
            progress = 10 + Math.floor(((i + 1) / validCampaigns.length) * 90);
            progressCallback(progress);
          }
          
        } catch (error) {
          console.error(`Error cloning campaign ${sourceCampaign.id}:`, error);
          errors.push({
            campaignId: sourceCampaign.id,
            error: error instanceof Error ? error.message : String(error)
          });
        }
      }
      
      return {
        success: errors.length === 0,
        createdCampaignIds,
        errors
      };
      
    } catch (error) {
      console.error("Campaign clone operation failed:", error);
      throw error;
    }
  }

  /**
   * Validate campaigns for cloning operation
   * Checks for any issues that might prevent successful cloning
   * 
   * @param campaignIds IDs of campaigns to validate
   * @param config Clone configuration
   */
  async validateCampaignsForCloning(
    campaignIds: string[],
    config: CampaignCloneConfig
  ): Promise<{
    valid: boolean,
    issues: any[],
    warnings: any[],
    estimatedImpact: {
      newKeywords: number,
      newAdGroups: number,
      newCampaigns: number,
      estimatedCost: number
    }
  }> {
    // Mock implementation
    const issues: any[] = [];
    const warnings: any[] = [];
    let keywordCount = 0;
    let adGroupCount = 0;
    
    // Fetch campaigns
    const campaigns = await Promise.all(
      campaignIds.map(id => this.getCampaignById(id))
    );
    
    const validCampaigns = campaigns.filter(
      (campaign): campaign is Campaign => campaign !== null
    );
    
    // Check for naming conflicts
    for (const campaign of validCampaigns) {
      const newName = this.generateCloneName(
        campaign.name,
        config.namingPattern,
        config.sourceMatchType,
        config.targetMatchType
      );
      
      // Count adgroups and keywords for impact assessment
      campaign.adGroups.forEach(adGroup => {
        adGroupCount++;
        keywordCount += adGroup.keywords.length;
      });
      
      // Check for any naming conflicts (mock)
      if (newName.includes('Conflict')) {
        issues.push({
          campaignId: campaign.id,
          message: `Campaign name '${newName}' conflicts with existing campaign`
        });
      }
      
      // Check match type
      const hasWrongMatchType = campaign.adGroups.some(adGroup => 
        adGroup.keywords.some(keyword => keyword.matchType !== config.sourceMatchType)
      );
      
      if (hasWrongMatchType) {
        warnings.push({
          campaignId: campaign.id,
          message: `Campaign contains keywords that are not ${config.sourceMatchType} match type`
        });
      }
    }
    
    // Estimated cost calculation (mock)
    const estimatedCostPerKeyword = 5.0; // Mock value
    const estimatedCost = keywordCount * estimatedCostPerKeyword;
    
    return {
      valid: issues.length === 0,
      issues,
      warnings,
      estimatedImpact: {
        newKeywords: keywordCount,
        newAdGroups: adGroupCount,
        newCampaigns: validCampaigns.length,
        estimatedCost
      }
    };
  }
  
  /**
   * Convert keywords in ad groups to the target match type
   * Optionally adjusts bids based on configuration
   */
  private convertAdGroupKeywords(
    adGroups: AdGroup[],
    sourceMatchType: MatchType,
    targetMatchType: MatchType,
    bidAdjustmentFactor?: number
  ): AdGroup[] {
    return adGroups.map(adGroup => {
      const updatedKeywords = adGroup.keywords.map(keyword => {
        // Only convert keywords of the source match type
        if (keyword.matchType === sourceMatchType) {
          const newKeyword = { ...keyword, matchType: targetMatchType };
          
          // Adjust bid if specified
          if (bidAdjustmentFactor && keyword.cpcBid) {
            newKeyword.cpcBid = keyword.cpcBid * bidAdjustmentFactor;
          }
          
          return newKeyword;
        }
        return keyword;
      });
      
      return { ...adGroup, keywords: updatedKeywords };
    });
  }
  
  /**
   * Extract keywords to use as negatives in the cloned campaign
   * Based on the campaign clone operation best practices
   */
  private extractKeywordsForNegatives(
    campaign: Campaign,
    matchType: MatchType
  ): Keyword[] {
    const negativeKeywords: Keyword[] = [];
    
    // For each adgroup, extract keywords of the specified match type
    campaign.adGroups.forEach(adGroup => {
      adGroup.keywords.forEach(keyword => {
        if (keyword.matchType === matchType) {
          negativeKeywords.push({
            ...keyword,
            id: `neg_${keyword.id}`,
            status: 'enabled'
          });
        }
      });
    });
    
    return negativeKeywords;
  }
  
  /**
   * Add negative keywords to a campaign
   * Used in the campaign clone operation
   */
  private async addNegativeKeywords(
    campaignId: string,
    keywords: Keyword[]
  ): Promise<void> {
    // Mock implementation - would make API call in real version
    console.log(`Added ${keywords.length} negative keywords to campaign ${campaignId}`);
  }
  
  /**
   * Generate a name for the cloned campaign based on the configured pattern
   */
  private generateCloneName(
    originalName: string,
    pattern: string,
    sourceMatchType: MatchType,
    targetMatchType: MatchType
  ): string {
    return pattern
      .replace('{originalName}', originalName)
      .replace('{sourceMatchType}', this.formatMatchType(sourceMatchType))
      .replace('{targetMatchType}', this.formatMatchType(targetMatchType));
  }
  
  /**
   * Format match type for display (capitalize first letter)
   */
  private formatMatchType(matchType: MatchType): string {
    return matchType.charAt(0).toUpperCase() + matchType.slice(1);
  }
  
  /**
   * Get a campaign by ID
   * Mock implementation for testing
   */
  private async getCampaignById(id: string): Promise<Campaign | null> {
    const mockCampaigns = this.getMockCampaigns();
    return mockCampaigns.find(campaign => campaign.id === id) || null;
  }
  
  /**
   * Get mock campaign data for testing
   */
  private getMockCampaigns(): Campaign[] {
    return [
      {
        id: "1",
        name: "Brand Campaign - Exact",
        status: "enabled",
        budget: {
          amount: 100,
          deliveryMethod: "standard"
        },
        bidStrategy: "manual_cpc",
        networkSettings: {
          targetGoogleSearch: true,
          targetSearchNetwork: true,
          targetContentNetwork: false,
          targetPartnerSearchNetwork: false
        },
        adGroups: [
          {
            id: "1-1",
            name: "Main Products",
            status: "enabled",
            cpcBid: 1.5,
            keywords: [
              {
                id: "1-1-1",
                text: "company name",
                matchType: "exact",
                status: "enabled",
                cpcBid: 2.0,
                performanceMetrics: {
                  impressions: 1200,
                  clicks: 120,
                  cost: 240,
                  conversions: 10,
                  averageCpc: 2.0,
                  ctr: 0.1
                }
              },
              {
                id: "1-1-2",
                text: "company product",
                matchType: "exact",
                status: "enabled",
                cpcBid: 1.8,
                performanceMetrics: {
                  impressions: 800,
                  clicks: 70,
                  cost: 126,
                  conversions: 6,
                  averageCpc: 1.8,
                  ctr: 0.0875
                }
              }
            ],
            ads: [
              {
                id: "1-1-1-1",
                type: "responsive_search",
                headlines: [
                  { text: "Official Company Store" },
                  { text: "Quality Products" },
                  { text: "Shop Now" }
                ],
                descriptions: [
                  { text: "Find the best products at the best prices." },
                  { text: "Free shipping on orders over $50." }
                ],
                finalUrls: ["https://example.com/store"]
              }
            ]
          }
        ],
        labels: ["brand", "high-performance"],
        startDate: "2025-01-01",
        createdAt: "2025-01-01T00:00:00Z",
        accountId: "123456789"
      },
      {
        id: "2",
        name: "Generic Products - Exact",
        status: "enabled",
        budget: {
          amount: 150,
          deliveryMethod: "standard"
        },
        bidStrategy: "target_roas",
        targetRoas: 300,
        networkSettings: {
          targetGoogleSearch: true,
          targetSearchNetwork: true,
          targetContentNetwork: false,
          targetPartnerSearchNetwork: false
        },
        adGroups: [
          {
            id: "2-1",
            name: "Product Category A",
            status: "enabled",
            keywords: [
              {
                id: "2-1-1",
                text: "product category",
                matchType: "exact",
                status: "enabled",
                performanceMetrics: {
                  impressions: 2500,
                  clicks: 180,
                  cost: 360,
                  conversions: 12,
                  averageCpc: 2.0,
                  ctr: 0.072
                }
              },
              {
                id: "2-1-2",
                text: "best product",
                matchType: "exact",
                status: "enabled",
                performanceMetrics: {
                  impressions: 1800,
                  clicks: 150,
                  cost: 300,
                  conversions: 9,
                  averageCpc: 2.0,
                  ctr: 0.0833
                }
              }
            ],
            ads: [
              {
                id: "2-1-1-1",
                type: "responsive_search",
                headlines: [
                  { text: "Top Rated Products" },
                  { text: "Best Selection Online" },
                  { text: "Shop Today" }
                ],
                descriptions: [
                  { text: "Find the perfect product for your needs." },
                  { text: "Fast shipping and easy returns." }
                ],
                finalUrls: ["https://example.com/products"]
              }
            ]
          }
        ],
        labels: ["generic", "high-volume"],
        startDate: "2025-01-15",
        createdAt: "2025-01-15T00:00:00Z",
        accountId: "123456789"
      }
    ];
  }
}

export default CampaignService.getInstance();
